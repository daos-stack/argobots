 test/basic/Makefile.am       |   8 +-
 test/basic/info_stackdump.c  | 211 ++++++++++++++++++++++++++++++++
 test/basic/info_stackdump2.c | 226 +++++++++++++++++++++++++++++++++++
 4 files changed, 446 insertions(+), 1 deletion(-)
 create mode 100644 test/basic/info_stackdump.c
 create mode 100644 test/basic/info_stackdump2.c

diff --git a/test/basic/Makefile.am b/test/basic/Makefile.am
index e09e222..ab45b62 100644
--- a/test/basic/Makefile.am
+++ b/test/basic/Makefile.am
@@ -56,7 +56,9 @@ TESTS = \
 	ext_thread \
 	ext_thread2 \
 	timer \
-	info_print
+	info_print \
+	info_stackdump \
+	info_stackdump2
 
 XFAIL_TESTS =
 if ABT_CONFIG_DISABLE_POOL_ACCESS_CHECK
@@ -124,6 +126,8 @@ ext_thread_SOURCES = ext_thread.c
 ext_thread2_SOURCES = ext_thread2.c
 timer_SOURCES = timer.c
 info_print_SOURCES = info_print.c
+info_stackdump_SOURCES = info_stackdump.c
+info_stackdump2_SOURCES = info_stackdump2.c
 
 testing:
 	./init_finalize
@@ -179,3 +183,5 @@ testing:
 	./ext_thread2
 	./timer
 	./info_print
+	./info_stackdump
+	./info_stackdump2
diff --git a/test/basic/info_stackdump.c b/test/basic/info_stackdump.c
new file mode 100644
index 0000000..1a380af
--- /dev/null
+++ b/test/basic/info_stackdump.c
@@ -0,0 +1,211 @@
+/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil ; -*- */
+/*
+ * See COPYRIGHT in top-level directory.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include "abt.h"
+#include "abttest.h"
+
+#define DEFAULT_NUM_XSTREAMS    4
+#define DEFAULT_NUM_THREADS     4
+
+int g_go = 0;
+
+void callback_f(ABT_bool timeout, void *arg)
+{
+    assert(timeout == ABT_FALSE);
+    assert((intptr_t)arg == (intptr_t)1);
+    g_go = 1;
+    __sync_synchronize();
+}
+
+void signal_handler(int sig)
+{
+    /* timeout is negative, so the timeout mechanism is disabled; all execution
+     * streams must execute ABT_xstream_check_events() in the scheduler. */
+    ABT_info_trigger_print_all_thread_stacks(stdout, -1.0, callback_f,
+                                             (void *)((intptr_t)1));
+    signal(SIGUSR1, signal_handler);
+}
+
+typedef struct thread_arg {
+    int id;
+    int issue_signal;
+    int *dummy_ptr;
+    void *stack;
+} thread_arg_t;
+
+void thread_func(void *arg)
+{
+    int i;
+    int rank;
+    ABT_thread_id id;
+    ABT_thread self;
+    thread_arg_t *t_arg = (thread_arg_t *)arg;
+
+    ABT_xstream_self_rank(&rank);
+    ABT_thread_self(&self);
+    ABT_thread_get_id(self, &id);
+    t_arg->id = (int)id;
+
+    ATS_printf(1, "[U%d:E%d] START\n", t_arg->id, rank);
+
+    /* Write data into a stack */
+    t_arg->dummy_ptr = (int *)alloca(sizeof(int) * 128);
+    for (i = 0; i < 128; i += 2) {
+        t_arg->dummy_ptr[i + 0] = id;
+        t_arg->dummy_ptr[i + 1] = rank;
+    }
+
+    ATS_printf(1, "[U%d:E%d] END\n", t_arg->id, rank);
+
+    ABT_thread_yield();
+
+    if (t_arg->issue_signal) {
+        ATS_printf(1, "[U%d:E%d] Raise SIGUSR1\n", t_arg->id, rank);
+        raise(SIGUSR1);
+    }
+
+    while (g_go == 0) {
+        __sync_synchronize();
+        ABT_thread_yield();
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    int i, j;
+    int ret;
+    int num_xstreams = DEFAULT_NUM_XSTREAMS;
+    int num_threads = DEFAULT_NUM_THREADS;
+
+    /* Set a signal handler */
+    signal(SIGUSR1, signal_handler);
+
+    /* Initialize */
+    ATS_read_args(argc, argv);
+    if (argc >= 2) {
+        num_xstreams = ATS_get_arg_val(ATS_ARG_N_ES);
+        num_threads = ATS_get_arg_val(ATS_ARG_N_ULT);
+    }
+    ATS_init(argc, argv, num_xstreams);
+
+    ATS_printf(2, "# of ESs : %d\n", num_xstreams);
+    ATS_printf(1, "# of ULTs: %d\n", num_threads);
+
+    ABT_xstream *xstreams;
+    ABT_thread **threads;
+    thread_arg_t **args;
+    xstreams = (ABT_xstream *)malloc(sizeof(ABT_xstream) * num_xstreams);
+    assert(xstreams != NULL);
+    threads = (ABT_thread **)malloc(sizeof(ABT_thread *) * num_xstreams);
+    assert(threads != NULL);
+    args = (thread_arg_t **)malloc(sizeof(thread_arg_t *) * num_xstreams);
+    assert(args != NULL);
+    for (i = 0; i < num_xstreams; i++) {
+        threads[i] = (ABT_thread *)malloc(sizeof(ABT_thread) * num_threads);
+        args[i] = (thread_arg_t *)malloc(sizeof(thread_arg_t) * num_threads);
+    }
+
+    /* Create execution streams */
+    ret = ABT_xstream_self(&xstreams[0]);
+    ATS_ERROR(ret, "ABT_xstream_self");
+    for (i = 1; i < num_xstreams; i++) {
+        ret = ABT_xstream_create(ABT_SCHED_NULL, &xstreams[i]);
+        ATS_ERROR(ret, "ABT_xstream_create");
+    }
+
+    /* Get the pools attached to an execution stream */
+    ABT_pool *pools;
+    pools = (ABT_pool *)malloc(sizeof(ABT_pool) * num_xstreams);
+    for (i = 0; i < num_xstreams; i++) {
+        ret = ABT_xstream_get_main_pools(xstreams[i], 1, pools + i);
+        ATS_ERROR(ret, "ABT_xstream_get_main_pools");
+    }
+
+    /* Create ULTs */
+    for (i = 0; i < num_xstreams; i++) {
+        for (j = 0; j < num_threads; j++) {
+            int tid = i * num_threads + j + 1;
+            args[i][j].id = tid;
+            args[i][j].issue_signal = (i == num_xstreams / 2)
+                                      && (j == num_threads / 2);
+            args[i][j].dummy_ptr = NULL;
+            args[i][j].stack = NULL;
+            if (tid % 3 == 0) {
+                ret = ABT_thread_create(pools[i], thread_func,
+                                        (void *)&args[i][j],
+                                        ABT_THREAD_ATTR_NULL, &threads[i][j]);
+                ATS_ERROR(ret, "ABT_thread_create");
+            } else if (tid % 3 == 1) {
+                ABT_thread_attr attr;
+                ret = ABT_thread_attr_create(&attr);
+                ATS_ERROR(ret, "ABT_thread_attr_create");
+                ret = ABT_thread_attr_set_stacksize(attr, 32768);
+                ATS_ERROR(ret, "ABT_thread_attr_set_stacksize");
+                ret = ABT_thread_create(pools[i], thread_func,
+                                        (void *)&args[i][j],
+                                        attr, &threads[i][j]);
+                ATS_ERROR(ret, "ABT_thread_create");
+                ret = ABT_thread_attr_free(&attr);
+                ATS_ERROR(ret, "ABT_thread_attr_free");
+            } else {
+                const size_t stacksize = 32768;
+                args[i][j].stack = malloc(stacksize);
+                ABT_thread_attr attr;
+                ret = ABT_thread_attr_create(&attr);
+                ATS_ERROR(ret, "ABT_thread_attr_create");
+                ret = ABT_thread_attr_set_stack(attr, args[i][j].stack,
+                                                stacksize);
+                ATS_ERROR(ret, "ABT_thread_attr_set_stack");
+                ret = ABT_thread_create(pools[i], thread_func,
+                                        (void *)&args[i][j],
+                                        attr, &threads[i][j]);
+                ATS_ERROR(ret, "ABT_thread_create");
+                ret = ABT_thread_attr_free(&attr);
+                ATS_ERROR(ret, "ABT_thread_attr_free");
+            }
+        }
+    }
+
+    /* Join and free ULTs */
+    for (i = 0; i < num_xstreams; i++) {
+        for (j = 0; j < num_threads; j++) {
+            ret = ABT_thread_free(&threads[i][j]);
+            ATS_ERROR(ret, "ABT_thread_free");
+        }
+    }
+
+    /* Join Execution Streams */
+    for (i = 1; i < num_xstreams; i++) {
+        ret = ABT_xstream_join(xstreams[i]);
+        ATS_ERROR(ret, "ABT_xstream_join");
+    }
+
+    /* Free Execution Streams */
+    for (i = 1; i < num_xstreams; i++) {
+        ret = ABT_xstream_free(&xstreams[i]);
+        ATS_ERROR(ret, "ABT_xstream_free");
+    }
+
+    /* Finalize */
+    ret = ATS_finalize(0);
+
+    for (i = 0; i < num_xstreams; i++) {
+        for (j = 0; j < num_threads; j++) {
+            if (args[i][j].stack)
+                free(args[i][j].stack);
+        }
+        free(threads[i]);
+        free(args[i]);
+    }
+    free(threads);
+    free(args);
+    free(xstreams);
+    free(pools);
+
+    return ret;
+}
diff --git a/test/basic/info_stackdump2.c b/test/basic/info_stackdump2.c
new file mode 100644
index 0000000..107b768
--- /dev/null
+++ b/test/basic/info_stackdump2.c
@@ -0,0 +1,226 @@
+/* -*- Mode: C; c-basic-offset:4 ; indent-tabs-mode:nil ; -*- */
+/*
+ * See COPYRIGHT in top-level directory.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <signal.h>
+#include "abt.h"
+#include "abttest.h"
+
+#define DEFAULT_NUM_XSTREAMS    4
+#define DEFAULT_NUM_THREADS     8
+
+int g_counter = 0;
+int g_stop = 0;
+
+void callback_f(ABT_bool timeout, void *arg)
+{
+    assert(timeout == ABT_TRUE);
+    assert((intptr_t)arg == (intptr_t)1);
+    g_stop = 0;
+    __sync_synchronize();
+}
+
+void signal_handler(int sig)
+{
+    /* In this test, some execution streams busy-wait in thread_func, so
+     * timeout is set to a positive value so that this mechanism works even if
+     * some execution streams hang.  */
+    ABT_info_trigger_print_all_thread_stacks(stdout, 3.0, callback_f,
+                                             (void *)((intptr_t)1));
+    signal(SIGUSR1, signal_handler);
+}
+
+typedef struct thread_arg {
+    int id;
+    int issue_signal;
+    int stop;
+    int num_xstreams;
+    int *dummy_ptr;
+    void *stack;
+} thread_arg_t;
+
+void thread_func(void *arg)
+{
+    int i;
+    int rank;
+    ABT_thread_id id;
+    ABT_thread self;
+    thread_arg_t *t_arg = (thread_arg_t *)arg;
+
+    ABT_xstream_self_rank(&rank);
+    ABT_thread_self(&self);
+    ABT_thread_get_id(self, &id);
+    t_arg->id = (int)id;
+
+    ATS_printf(1, "[U%d:E%d] START\n", t_arg->id, rank);
+
+    /* Write data into a stack */
+    t_arg->dummy_ptr = (int *)alloca(sizeof(int) * 128);
+    for (i = 0; i < 128; i += 2) {
+        t_arg->dummy_ptr[i + 0] = id;
+        t_arg->dummy_ptr[i + 1] = rank;
+    }
+
+    ATS_printf(1, "[U%d:E%d] END\n", t_arg->id, rank);
+
+    ABT_thread_yield();
+
+    if (t_arg->issue_signal) {
+        ATS_printf(1, "[U%d:E%d] Raise SIGUSR1\n", t_arg->id, rank);
+        g_stop = 1;
+        while (g_counter < t_arg->num_xstreams - 2) {
+            /* ensure that all the non-master execution streams are waiting in
+             * the following busy loop. */
+            __sync_synchronize();
+        }
+        raise(SIGUSR1);
+    }
+
+    if (t_arg->stop) {
+        __sync_add_and_fetch(&g_counter, 1);
+        while (g_stop == 1) {
+            __sync_synchronize();
+        }
+    }
+}
+
+int main(int argc, char *argv[])
+{
+    int i, j;
+    int ret;
+    int num_xstreams = DEFAULT_NUM_XSTREAMS;
+    int num_threads = DEFAULT_NUM_THREADS;
+
+    /* Set a signal handler */
+    signal(SIGUSR1, signal_handler);
+
+    /* Initialize */
+    ATS_read_args(argc, argv);
+    if (argc >= 2) {
+        num_xstreams = ATS_get_arg_val(ATS_ARG_N_ES);
+        num_threads = ATS_get_arg_val(ATS_ARG_N_ULT);
+    }
+    ATS_init(argc, argv, num_xstreams);
+
+    ATS_printf(2, "# of ESs : %d\n", num_xstreams);
+    ATS_printf(1, "# of ULTs: %d\n", num_threads);
+
+    ABT_xstream *xstreams;
+    ABT_thread **threads;
+    thread_arg_t **args;
+    xstreams = (ABT_xstream *)malloc(sizeof(ABT_xstream) * num_xstreams);
+    assert(xstreams != NULL);
+    threads = (ABT_thread **)malloc(sizeof(ABT_thread *) * num_xstreams);
+    assert(threads != NULL);
+    args = (thread_arg_t **)malloc(sizeof(thread_arg_t *) * num_xstreams);
+    assert(args != NULL);
+    for (i = 0; i < num_xstreams; i++) {
+        threads[i] = (ABT_thread *)malloc(sizeof(ABT_thread) * num_threads);
+        args[i] = (thread_arg_t *)malloc(sizeof(thread_arg_t) * num_threads);
+    }
+
+    /* Create execution streams */
+    ret = ABT_xstream_self(&xstreams[0]);
+    ATS_ERROR(ret, "ABT_xstream_self");
+    for (i = 1; i < num_xstreams; i++) {
+        ret = ABT_xstream_create(ABT_SCHED_NULL, &xstreams[i]);
+        ATS_ERROR(ret, "ABT_xstream_create");
+    }
+
+    /* Get the pools attached to an execution stream */
+    ABT_pool *pools;
+    pools = (ABT_pool *)malloc(sizeof(ABT_pool) * num_xstreams);
+    for (i = 0; i < num_xstreams; i++) {
+        ret = ABT_xstream_get_main_pools(xstreams[i], 1, pools + i);
+        ATS_ERROR(ret, "ABT_xstream_get_main_pools");
+    }
+
+    /* Create ULTs. */
+    /* i starts from 1 because one execution stream must be busy-scheduling. */
+    for (i = 1; i < num_xstreams; i++) {
+        for (j = 0; j < num_threads; j++) {
+            int tid = i * num_threads + j + 1;
+            args[i][j].id = tid;
+            args[i][j].issue_signal = (i == ((num_xstreams - 1) / 2) + 1)
+                                      && (j == num_threads / 2);
+            args[i][j].stop = (j == num_threads / 2);
+            args[i][j].num_xstreams = num_xstreams;
+            args[i][j].dummy_ptr = NULL;
+            args[i][j].stack = NULL;
+            if (tid % 3 == 0) {
+                ret = ABT_thread_create(pools[i], thread_func,
+                                        (void *)&args[i][j],
+                                        ABT_THREAD_ATTR_NULL, &threads[i][j]);
+                ATS_ERROR(ret, "ABT_thread_create");
+            } else if (tid % 3 == 1) {
+                ABT_thread_attr attr;
+                ret = ABT_thread_attr_create(&attr);
+                ATS_ERROR(ret, "ABT_thread_attr_create");
+                ret = ABT_thread_attr_set_stacksize(attr, 32768);
+                ATS_ERROR(ret, "ABT_thread_attr_set_stacksize");
+                ret = ABT_thread_create(pools[i], thread_func,
+                                        (void *)&args[i][j],
+                                        attr, &threads[i][j]);
+                ATS_ERROR(ret, "ABT_thread_create");
+                ret = ABT_thread_attr_free(&attr);
+                ATS_ERROR(ret, "ABT_thread_attr_free");
+            } else {
+                const size_t stacksize = 32768;
+                args[i][j].stack = malloc(stacksize);
+                ABT_thread_attr attr;
+                ret = ABT_thread_attr_create(&attr);
+                ATS_ERROR(ret, "ABT_thread_attr_create");
+                ret = ABT_thread_attr_set_stack(attr, args[i][j].stack,
+                                                stacksize);
+                ATS_ERROR(ret, "ABT_thread_attr_set_stack");
+                ret = ABT_thread_create(pools[i], thread_func,
+                                        (void *)&args[i][j],
+                                        attr, &threads[i][j]);
+                ATS_ERROR(ret, "ABT_thread_create");
+                ret = ABT_thread_attr_free(&attr);
+                ATS_ERROR(ret, "ABT_thread_attr_free");
+            }
+        }
+    }
+
+    /* Join and free ULTs */
+    for (i = 1; i < num_xstreams; i++) {
+        for (j = 0; j < num_threads; j++) {
+            ret = ABT_thread_free(&threads[i][j]);
+            ATS_ERROR(ret, "ABT_thread_free");
+        }
+    }
+
+    /* Join Execution Streams */
+    for (i = 1; i < num_xstreams; i++) {
+        ret = ABT_xstream_join(xstreams[i]);
+        ATS_ERROR(ret, "ABT_xstream_join");
+    }
+
+    /* Free Execution Streams */
+    for (i = 1; i < num_xstreams; i++) {
+        ret = ABT_xstream_free(&xstreams[i]);
+        ATS_ERROR(ret, "ABT_xstream_free");
+    }
+
+    /* Finalize */
+    ret = ATS_finalize(0);
+
+    for (i = 0; i < num_xstreams; i++) {
+        for (j = 0; j < num_threads; j++) {
+            if (args[i][j].stack)
+                free(args[i][j].stack);
+        }
+        free(threads[i]);
+        free(args[i]);
+    }
+    free(threads);
+    free(args);
+    free(xstreams);
+    free(pools);
+
+    return ret;
+}

From af7ae4bc3b1ca0f3e2e02e871324dd1705c053e7 Mon Sep 17 00:00:00 2001
From: Matthieu Dorier <mdorier@anl.gov>
Date: Wed, 4 Sep 2019 08:33:43 -0500
Subject: [PATCH 7/9] made possible to remove error messages from std output

---
 configure.ac             | 11 +++++++++++
 src/include/abti_error.h | 11 +++++++++++
 2 files changed, 22 insertions(+)

diff --git a/configure.ac b/configure.ac
index be06847..f58d67c 100644
--- a/configure.ac
+++ b/configure.ac
@@ -101,6 +101,7 @@ AC_ARG_ENABLE([debug],
         all   - all of the above choices
         most  - same as "all" but not print logs by default
                 (set ABT_ENV_USE_LOG to 1 for logging)
+        err   - print abt_errno information on standard error
         none  - no debugging, i.e., --disable-debug
 ],,[enable_debug=none])
 
@@ -301,18 +302,25 @@ for option in $enable_debug ; do
         log)
             debug_log=yes
             debug_log_print=yes
+            debug_err=yes
         ;;
         all)
             debug_flags=yes
             debug_log=yes
             debug_log_print=yes
+            debug_err=yes
         ;;
         most)
             debug_flags=yes
             debug_log=yes
             debug_log_print=no
+            debug_err=yes
+        ;;
+        err)
+            debug_err=yes
         ;;
         no|none)
+            debug_err=no
             debug_flags=no
             debug_log=no
         ;;
@@ -338,6 +346,9 @@ AS_IF([test "x$debug_log" = "xyes"],
 AS_IF([test "x$debug_log_print" = "xyes"],
     [AC_DEFINE(ABT_CONFIG_USE_DEBUG_LOG_PRINT, 1,
         [Define to enable printing debug log messages])])
+AS_IF([test "x$debug_err" = "xyes"],
+    [AC_DEFINE(ABT_CONFIG_PRINT_ABT_ERRNO, 1,
+        [Define to enable printing abt_errno upon abt call error])])
 
 
 # --enable-fast: compiler optimization flags
diff --git a/src/include/abti_error.h b/src/include/abti_error.h
index f2e9cae..2af30d2 100644
--- a/src/include/abti_error.h
+++ b/src/include/abti_error.h
@@ -7,6 +7,7 @@
 #define ABTI_ERROR_H_INCLUDED
 
 #include <assert.h>
+#include <abt_config.h>
 
 #ifndef ABT_CONFIG_DISABLE_ERROR_CHECK
 #define ABTI_ASSERT(cond) assert(cond)
@@ -270,6 +271,8 @@
 #define ABTI_CHECK_NULL_TIMER_PTR(p)
 #endif
 
+#ifdef ABT_CONFIG_PRINT_ABT_ERRNO
+
 #define HANDLE_ERROR(msg) \
     fprintf(stderr, "[%s:%d] %s\n", __FILE__, __LINE__, msg)
     //fprintf(stderr, "[%s:%d] %s\n", __FILE__, __LINE__, msg); exit(-1)
@@ -282,4 +285,12 @@
     fprintf(stderr, "[%s:%d] %s: %d\n", __FILE__, __LINE__, __func__, n)
     //fprintf(stderr, "[%s:%d] %s: %d\n", __FILE__, __LINE__, __func__, n); exit(-1)
 
+#else
+
+#define HANDLE_ERROR(msg)              do { } while (0)
+#define HANDLE_ERROR_WITH_CODE(msg,n)  do { } while (0)
+#define HANDLE_ERROR_FUNC_WITH_CODE(n) do { } while (0)
+
+#endif
+
 #endif /* ABTI_ERROR_H_INCLUDED */

From 8eec91806fa2ce28c5cf39b4319a2223ee93535e Mon Sep 17 00:00:00 2001
From: Jeff Olivier <jeffrey.v.olivier@intel.com>
Date: Wed, 18 Sep 2019 10:52:51 -0600
Subject: [PATCH 8/9] Disable expensive valgrind specific tracking if valgrind
 isn't running. This enables users of argobots to keep one build that supports
 valgrind without losing significant performance.

Signed-off-by: Jeff Olivier <jeffrey.v.olivier@intel.com>
---
 src/mem/valgrind.c | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/src/mem/valgrind.c b/src/mem/valgrind.c
index 0839048..823106d 100644
--- a/src/mem/valgrind.c
+++ b/src/mem/valgrind.c
@@ -45,6 +45,9 @@ void ABTI_valgrind_register_stack(const void *p_stack, size_t size) {
     if (p_stack == 0)
         return;
 
+    if (!RUNNING_ON_VALGRIND)
+	    return;
+
     const void *p_start = (char *)(p_stack);
     const void *p_end   = (char *)(p_stack) + size;
 
@@ -71,6 +74,9 @@ void ABTI_valgrind_unregister_stack(const void *p_stack) {
     if (p_stack == 0)
         return;
 
+    if (!RUNNING_ON_VALGRIND)
+	    return;
+
     ABTI_valgrind_lock_acquire();
     if (gp_valgrind_id_list_head->p_stack == p_stack) {
         VALGRIND_STACK_DEREGISTER(gp_valgrind_id_list_head->valgrind_id);

From 89507c1f8cfec4e918e8b9861e41b4e9cef71461 Mon Sep 17 00:00:00 2001
From: Jeff Olivier <jeffrey.v.olivier@intel.com>
Date: Wed, 18 Sep 2019 11:40:00 -0600
Subject: [PATCH 9/9] Move the checks to the header file

Signed-off-by: Jeff Olivier <jeffrey.v.olivier@intel.com>
---
 src/include/abti_valgrind.h | 17 +++++++++++++----
 src/mem/valgrind.c          |  6 ------
 2 files changed, 13 insertions(+), 10 deletions(-)

diff --git a/src/include/abti_valgrind.h b/src/include/abti_valgrind.h
index f1b724d..f340cd4 100644
--- a/src/include/abti_valgrind.h
+++ b/src/include/abti_valgrind.h
@@ -13,10 +13,19 @@
 
 void ABTI_valgrind_register_stack(const void *p_stack, size_t size);
 void ABTI_valgrind_unregister_stack(const void *p_stack);
-#define ABTI_VALGRIND_REGISTER_STACK(p_stack, size) \
-            ABTI_valgrind_register_stack  (p_stack, size)
-#define ABTI_VALGRIND_UNREGISTER_STACK(p_stack) \
-            ABTI_valgrind_unregister_stack(p_stack)
+#define ABTI_VALGRIND_REGISTER_STACK(p_stack, size)         \
+        do {                                                \
+            if (!RUNNING_ON_VALGRIND)                       \
+                break;                                      \
+            ABTI_valgrind_register_stack  (p_stack, size);  \
+        } while (0)
+
+#define ABTI_VALGRIND_UNREGISTER_STACK(p_stack)         \
+        do {                                            \
+            if (!RUNNING_ON_VALGRIND)                   \
+                break;                                  \
+            ABTI_valgrind_unregister_stack(p_stack);    \
+        } while (0)
 
 #else
 
diff --git a/src/mem/valgrind.c b/src/mem/valgrind.c
index 823106d..0839048 100644
--- a/src/mem/valgrind.c
+++ b/src/mem/valgrind.c
@@ -45,9 +45,6 @@ void ABTI_valgrind_register_stack(const void *p_stack, size_t size) {
     if (p_stack == 0)
         return;
 
-    if (!RUNNING_ON_VALGRIND)
-	    return;
-
     const void *p_start = (char *)(p_stack);
     const void *p_end   = (char *)(p_stack) + size;
 
@@ -74,9 +71,6 @@ void ABTI_valgrind_unregister_stack(const void *p_stack) {
     if (p_stack == 0)
         return;
 
-    if (!RUNNING_ON_VALGRIND)
-	    return;
-
     ABTI_valgrind_lock_acquire();
     if (gp_valgrind_id_list_head->p_stack == p_stack) {
         VALGRIND_STACK_DEREGISTER(gp_valgrind_id_list_head->valgrind_id);
