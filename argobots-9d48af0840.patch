From 8eeb9c5d240abbeaa36cdf61dc61c2db54841c81 Mon Sep 17 00:00:00 2001
From: Shintaro Iwasaki <siwasaki@anl.gov>
Date: Tue, 5 Feb 2019 13:15:08 -0600
Subject: [PATCH 1/5] thread: fix error when stackable scheduler is disabled.

Thread code uses is_sched. However, this variable is only declared when the
stackable scheduler is enabled. When this feature is disabled, compile-time
errors occur.

This commit fixes this issue by adding #ifdef macros.

Signed-off-by: Halim Amer <aamer@anl.gov>
---
 src/arch/abtd_thread.c | 12 ++++++++++++
 src/thread.c           |  4 ++++
 2 files changed, 16 insertions(+)

diff --git a/src/arch/abtd_thread.c b/src/arch/abtd_thread.c
index 8092962..18b46e6 100644
--- a/src/arch/abtd_thread.c
+++ b/src/arch/abtd_thread.c
@@ -74,11 +74,15 @@ void ABTD_thread_func_wrapper(int func_upper, int func_lower,
 
 void ABTD_thread_exit(ABTI_thread *p_thread)
 {
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     if (p_thread->is_sched) {
         ABTD_thread_terminate_sched(p_thread);
     } else {
+#endif
         ABTD_thread_terminate_thread(p_thread);
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     }
+#endif
 }
 
 static inline void ABTDI_thread_terminate(ABTI_thread *p_thread,
@@ -104,12 +108,16 @@ static inline void ABTDI_thread_terminate(ABTI_thread *p_thread,
              * type ULT would be a joiner (=suspend), no scheduler is available
              * when a running ULT needs suspension. Hence, it always jumps to a
              * non-scheduler-type ULT. */
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
             if (is_sched) {
                 ABTI_thread_finish_context_sched_to_thread(p_thread->is_sched,
                                                            p_joiner);
             } else {
+#endif
                 ABTI_thread_finish_context_thread_to_thread(p_thread, p_joiner);
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
             }
+#endif
             return;
         } else {
             /* If the current ULT's associated ES is different from p_joiner's,
@@ -151,11 +159,15 @@ static inline void ABTDI_thread_terminate(ABTI_thread *p_thread,
 #ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     }
 #endif
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     if (is_sched) {
         ABTI_thread_finish_context_sched_to_sched(p_thread->is_sched, p_sched);
     } else {
+#endif
         ABTI_thread_finish_context_thread_to_sched(p_thread, p_sched);
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     }
+#endif
 #else
 #error "Not implemented yet"
 #endif
diff --git a/src/thread.c b/src/thread.c
index f6a3774..06a5d8d 100644
--- a/src/thread.c
+++ b/src/thread.c
@@ -235,15 +235,19 @@ int ABT_thread_revive(ABT_pool pool, void(*thread_func)(void *), void *arg,
 
     /* Create a ULT context */
     stacksize = p_thread->attr.stacksize;
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     if (p_thread->is_sched) {
         abt_errno = ABTD_thread_context_create_sched(NULL, thread_func, arg,
                                            stacksize, p_thread->attr.p_stack,
                                            &p_thread->ctx);
     } else {
+#endif
         abt_errno = ABTD_thread_context_create_thread(NULL, thread_func, arg,
                                            stacksize, p_thread->attr.p_stack,
                                            &p_thread->ctx);
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     }
+#endif
     ABTI_CHECK_ERROR(abt_errno);
 
     p_thread->state          = ABT_THREAD_STATE_READY;

From 0e9043a53b932bbc7fb889e4bd12dfb5808ba6fe Mon Sep 17 00:00:00 2001
From: Shintaro Iwasaki <siwasaki@anl.gov>
Date: Tue, 5 Feb 2019 14:27:54 -0600
Subject: [PATCH 2/5] global: ensure thread safety of ABT_init/finalize

ABT_init has a mechanism to avoid multiple initializations, but it is
incomplete; if two kernel threads simultaneously call ABT_init, one of them may
return before the initialization is finished, which causes an error on any
attempts to use Argobots functions.

This commit fixes this issue by introducing a lock (g_ABTI_init_lock), which
protects ABT_init and finalize.

Signed-off-by: Halim Amer <aamer@anl.gov>
---
 src/global.c | 57 +++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 45 insertions(+), 12 deletions(-)

diff --git a/src/global.c b/src/global.c
index 41e9be8..9db3012 100644
--- a/src/global.c
+++ b/src/global.c
@@ -15,6 +15,26 @@ ABTI_global *gp_ABTI_global = NULL;
 
 /* To indicate how many times ABT_init is called. */
 static uint32_t g_ABTI_num_inits = 0;
+/* A global lock protecting the initialization/finalization process */
+static uint8_t g_ABTI_init_lock = 0;
+
+static inline void ABTI_init_lock_acquire() {
+    while (ABTD_atomic_test_and_set_uint8(&g_ABTI_init_lock)) {
+        /* Busy-wait is allowed since this function may not be run in
+         * ULT context. */
+        while (ABTD_atomic_load_uint8(&g_ABTI_init_lock) != 0)
+            ABTD_atomic_pause();
+    }
+}
+
+static inline int ABTI_init_lock_is_locked() {
+    return ABTD_atomic_load_uint8(&g_ABTI_init_lock) != 0;
+}
+
+static inline void ABTI_init_lock_release() {
+    ABTD_atomic_clear_uint8(&g_ABTI_init_lock);
+}
+
 
 /**
  * @ingroup ENV
@@ -37,9 +57,13 @@ int ABT_init(int argc, char **argv)
     ABTI_UNUSED(argc); ABTI_UNUSED(argv);
     int abt_errno = ABT_SUCCESS;
 
-    /* If Argobots has already been initialized, just return. */
-    uint32_t num_inits = ABTD_atomic_fetch_add_uint32(&g_ABTI_num_inits, 1);
-    if (num_inits > 0 || gp_ABTI_global != NULL) goto fn_exit;
+    /* First, take a global lock protecting the initialization/finalization
+     * process. Don't go to fn_exit before taking a lock */
+    ABTI_init_lock_acquire();
+
+    /* If Argobots has already been initialized, just return */
+    if (g_ABTI_num_inits++ > 0)
+        goto fn_exit;
 
     gp_ABTI_global = (ABTI_global *)ABTU_malloc(sizeof(ABTI_global));
 
@@ -95,6 +119,8 @@ int ABT_init(int argc, char **argv)
     }
 
   fn_exit:
+    /* Unlock a global lock */
+    ABTI_init_lock_release();
     return abt_errno;
 
   fn_fail:
@@ -122,14 +148,18 @@ int ABT_finalize(void)
 {
     int abt_errno = ABT_SUCCESS;
 
-    /* If Argobots is not initialized, just return. */
-    if (gp_ABTI_global == NULL || g_ABTI_num_inits == 0) {
+    /* First, take a global lock protecting the initialization/finalization
+     * process. Don't go to fn_exit before taking a lock */
+    ABTI_init_lock_acquire();
+
+    /* If Argobots is not initialized, just return */
+    if (g_ABTI_num_inits == 0) {
         abt_errno = ABT_ERR_UNINITIALIZED;
         goto fn_exit;
     }
-
-    uint32_t num_inits = ABTD_atomic_fetch_sub_uint32(&g_ABTI_num_inits, 1);
-    if (num_inits != 1) goto fn_exit;
+    /* If Argobots is still referenced by others, just return */
+    if (--g_ABTI_num_inits != 0)
+        goto fn_exit;
 
     /* If called by an external thread, return an error. */
     ABTI_CHECK_TRUE(lp_ABTI_local != NULL, ABT_ERR_INV_XSTREAM);
@@ -192,6 +222,8 @@ int ABT_finalize(void)
     gp_ABTI_global = NULL;
 
   fn_exit:
+    /* Unlock a global lock */
+    ABTI_init_lock_release();
     return abt_errno;
 
   fn_fail:
@@ -203,12 +235,13 @@ int ABT_finalize(void)
  * @ingroup ENV
  * @brief   Check whether \c ABT_init() has been called.
  *
- * \c ABT_initialized() returns \c ABT_SUCCESS if \c ABT_init() has been called.
- * Otherwise, it returns \c ABT_ERR_UNINITIALIZED.
+ * \c ABT_initialized() returns \c ABT_SUCCESS if the Argobots execution
+ * environment has been initialized. Otherwise, it returns
+ * \c ABT_ERR_UNINITIALIZED.
  *
  * @return Error code
- * @retval ABT_SUCCESS           if \c ABT_init() has been called.
- * @retval ABT_ERR_UNINITIALIZED if \c ABT_init() has not been called.
+ * @retval ABT_SUCCESS           if the environment has been initialized.
+ * @retval ABT_ERR_UNINITIALIZED if the environment has not been initialized.
  */
 int ABT_initialized(void)
 {

From 8291e66041947363f1024b59d8545b21fbb02783 Mon Sep 17 00:00:00 2001
From: Shintaro Iwasaki <siwasaki@anl.gov>
Date: Tue, 5 Feb 2019 14:29:21 -0600
Subject: [PATCH 3/5] global: ABT_initialized returns true only if Argobots is
 available.

ABT_initialized returns true even if Argobots has not been fully initialized;
ABT_initialized only checks gp_ABTI_global, which is set at the very beginning
of ABT_init.  This implementation is correct since the description says it
returns ABT_SUCCESS if ABT_init has been called, though it is useless.

This commit fixes this issue by introducing a new variable (g_ABTI_initialized),
which is set to TRUE if the Argobots execution environment is ready.

When ABT_finalize is executed concurrently, Argobots might be unavailable even
if ABT_initialized returns true.  This will be fixed in the future.

Signed-off-by: Halim Amer <aamer@anl.gov>
---
 src/global.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/src/global.c b/src/global.c
index 9db3012..cc36a3d 100644
--- a/src/global.c
+++ b/src/global.c
@@ -17,6 +17,8 @@ ABTI_global *gp_ABTI_global = NULL;
 static uint32_t g_ABTI_num_inits = 0;
 /* A global lock protecting the initialization/finalization process */
 static uint8_t g_ABTI_init_lock = 0;
+/* A flag whether Argobots has been initialized or not */
+static uint32_t g_ABTI_initialized = 0;
 
 static inline void ABTI_init_lock_acquire() {
     while (ABTD_atomic_test_and_set_uint8(&g_ABTI_init_lock)) {
@@ -117,6 +119,7 @@ int ABT_init(int argc, char **argv)
     if (gp_ABTI_global->print_config == ABT_TRUE) {
         ABT_info_print_config(stdout);
     }
+    ABTD_atomic_store_uint32(&g_ABTI_initialized, 1);
 
   fn_exit:
     /* Unlock a global lock */
@@ -220,6 +223,7 @@ int ABT_finalize(void)
     /* Free the ABTI_global structure */
     ABTU_free(gp_ABTI_global);
     gp_ABTI_global = NULL;
+    ABTD_atomic_store_uint32(&g_ABTI_initialized, 0);
 
   fn_exit:
     /* Unlock a global lock */
@@ -247,7 +251,7 @@ int ABT_initialized(void)
 {
     int abt_errno = ABT_SUCCESS;
 
-    if (gp_ABTI_global == NULL) {
+    if (ABTD_atomic_load_uint32(&g_ABTI_initialized) == 0) {
         abt_errno = ABT_ERR_UNINITIALIZED;
     }
 

From d1d25d649fd7339783a0a9d29728d0ddd996a568 Mon Sep 17 00:00:00 2001
From: Shintaro Iwasaki <siwasaki@anl.gov>
Date: Fri, 8 Feb 2019 16:32:19 -0600
Subject: [PATCH 4/5] atomic: fix ABTD_atomic_pause.

ABTD_atomic_pause() uses an x86/64 specific instruction. This commit adds a
preprocessor so that this instruction is not compiled on a non-x86/64
architecture.

Signed-off-by: Halim Amer <aamer@anl.gov>
---
 src/include/abtd_atomic.h | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/src/include/abtd_atomic.h b/src/include/abtd_atomic.h
index f88c3f4..7cb0e8e 100644
--- a/src/include/abtd_atomic.h
+++ b/src/include/abtd_atomic.h
@@ -739,7 +739,9 @@ void ABTD_compiler_barrier(void)
 static inline
 void ABTD_atomic_pause(void)
 {
+#ifdef __x86_64__
     __asm__ __volatile__ ( "pause" ::: "memory" );
+#endif
 }
 
 #endif /* ABTD_ATOMIC_H_INCLUDED */

From 9d48af08403bac649598942b5ee848c14600cd8a Mon Sep 17 00:00:00 2001
From: Shintaro Iwasaki <siwasaki@anl.gov>
Date: Thu, 21 Feb 2019 11:20:54 -0600
Subject: [PATCH 5/5] thread: fix an undefined is_sched error

With --enable-debug=yes and --enable-feature=no-stackable-sched, compilation
fails because is_sched is undefined in some ABTI_ASSERT calls.  This patch fixes
this issue by adding ifdef.

Signed-off-by: Halim Amer <aamer@anl.gov>
---
 src/arch/abtd_thread.c    | 4 ++++
 src/include/abti_thread.h | 6 ++++++
 2 files changed, 10 insertions(+)

diff --git a/src/arch/abtd_thread.c b/src/arch/abtd_thread.c
index 18b46e6..55f7a18 100644
--- a/src/arch/abtd_thread.c
+++ b/src/arch/abtd_thread.c
@@ -18,7 +18,9 @@ void ABTD_thread_func_wrapper_thread(void *p_arg)
 
     /* NOTE: ctx is located in the beginning of ABTI_thread */
     ABTI_thread *p_thread = (ABTI_thread *)p_fctx;
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     ABTI_ASSERT(p_thread->is_sched == NULL);
+#endif
 
     ABTD_thread_terminate_thread(p_thread);
 }
@@ -32,7 +34,9 @@ void ABTD_thread_func_wrapper_sched(void *p_arg)
 
     /* NOTE: ctx is located in the beginning of ABTI_thread */
     ABTI_thread *p_thread = (ABTI_thread *)p_fctx;
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     ABTI_ASSERT(p_thread->is_sched != NULL);
+#endif
 
     ABTD_thread_terminate_sched(p_thread);
 }
diff --git a/src/include/abti_thread.h b/src/include/abti_thread.h
index ea61533..438b6e0 100644
--- a/src/include/abti_thread.h
+++ b/src/include/abti_thread.h
@@ -143,7 +143,9 @@ void ABTI_thread_context_switch_thread_to_thread_internal(ABTI_thread *p_old,
                                                           ABTI_thread *p_new,
                                                           ABT_bool is_finish)
 {
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     ABTI_ASSERT(!p_old->is_sched && !p_new->is_sched);
+#endif
     ABTI_local_set_thread(p_new);
 #if ABT_CONFIG_THREAD_TYPE == ABT_THREAD_TYPE_DYNAMIC_PROMOTION
     /* Dynamic promotion is unnecessary if p_old is discarded. */
@@ -168,7 +170,9 @@ void ABTI_thread_context_switch_thread_to_sched_internal(ABTI_thread *p_old,
                                                          ABTI_sched *p_new,
                                                          ABT_bool is_finish)
 {
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     ABTI_ASSERT(!p_old->is_sched);
+#endif
     ABTI_LOG_SET_SCHED(p_new);
 #if ABT_CONFIG_THREAD_TYPE == ABT_THREAD_TYPE_DYNAMIC_PROMOTION
     /* Dynamic promotion is unnecessary if p_old is discarded. */
@@ -190,7 +194,9 @@ void ABTI_thread_context_switch_sched_to_thread_internal(ABTI_sched *p_old,
                                                          ABTI_thread *p_new,
                                                          ABT_bool is_finish)
 {
+#ifndef ABT_CONFIG_DISABLE_STACKABLE_SCHED
     ABTI_ASSERT(!p_new->is_sched);
+#endif
     ABTI_LOG_SET_SCHED(NULL);
     ABTI_local_set_thread(p_new);
     ABTI_local_set_task(NULL); /* A tasklet scheduler can invoke ULT. */
